// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: insights.sql

package store

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const archiveInsight = `-- name: ArchiveInsight :exec
UPDATE generated_insights
SET status = 'archived', updated_at = NOW()
WHERE id = $1 AND user_id = $2
`

type ArchiveInsightParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) ArchiveInsight(ctx context.Context, arg ArchiveInsightParams) error {
	_, err := q.db.Exec(ctx, archiveInsight, arg.ID, arg.UserID)
	return err
}

const cleanupOldInsights = `-- name: CleanupOldInsights :exec
DELETE FROM generated_insights
WHERE created_at < $1
  AND status IN ('archived', 'superseded')
`

func (q *Queries) CleanupOldInsights(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, cleanupOldInsights, createdAt)
	return err
}

const createInsight = `-- name: CreateInsight :one

INSERT INTO generated_insights (
    user_id, report_type, period_start, period_end, title,
    content, summary, metadata, generation_model,
    generation_duration_ms, quality_score
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, user_id, report_type, period_start, period_end, title, content, summary, metadata, generation_model, generation_duration_ms, quality_score, status, created_at, updated_at
`

type CreateInsightParams struct {
	UserID               uuid.UUID      `db:"user_id" json:"user_id"`
	ReportType           string         `db:"report_type" json:"report_type"`
	PeriodStart          pgtype.Date    `db:"period_start" json:"period_start"`
	PeriodEnd            pgtype.Date    `db:"period_end" json:"period_end"`
	Title                string         `db:"title" json:"title"`
	Content              string         `db:"content" json:"content"`
	Summary              pgtype.Text    `db:"summary" json:"summary"`
	Metadata             []byte         `db:"metadata" json:"metadata"`
	GenerationModel      pgtype.Text    `db:"generation_model" json:"generation_model"`
	GenerationDurationMs pgtype.Int4    `db:"generation_duration_ms" json:"generation_duration_ms"`
	QualityScore         pgtype.Numeric `db:"quality_score" json:"quality_score"`
}

// EngLog Insights Management Queries
// AI-generated insights and analytics
func (q *Queries) CreateInsight(ctx context.Context, arg CreateInsightParams) (GeneratedInsight, error) {
	row := q.db.QueryRow(ctx, createInsight,
		arg.UserID,
		arg.ReportType,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.Title,
		arg.Content,
		arg.Summary,
		arg.Metadata,
		arg.GenerationModel,
		arg.GenerationDurationMs,
		arg.QualityScore,
	)
	var i GeneratedInsight
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ReportType,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.Title,
		&i.Content,
		&i.Summary,
		&i.Metadata,
		&i.GenerationModel,
		&i.GenerationDurationMs,
		&i.QualityScore,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInsight = `-- name: DeleteInsight :exec
DELETE FROM generated_insights
WHERE id = $1 AND user_id = $2
`

type DeleteInsightParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteInsight(ctx context.Context, arg DeleteInsightParams) error {
	_, err := q.db.Exec(ctx, deleteInsight, arg.ID, arg.UserID)
	return err
}

const getInsightByID = `-- name: GetInsightByID :one
SELECT id, user_id, report_type, period_start, period_end, title, content, summary, metadata, generation_model, generation_duration_ms, quality_score, status, created_at, updated_at FROM generated_insights
WHERE id = $1
`

func (q *Queries) GetInsightByID(ctx context.Context, id uuid.UUID) (GeneratedInsight, error) {
	row := q.db.QueryRow(ctx, getInsightByID, id)
	var i GeneratedInsight
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ReportType,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.Title,
		&i.Content,
		&i.Summary,
		&i.Metadata,
		&i.GenerationModel,
		&i.GenerationDurationMs,
		&i.QualityScore,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInsightGenerationMetrics = `-- name: GetInsightGenerationMetrics :many
SELECT
    report_type,
    COUNT(*) as total_generated,
    AVG(generation_duration_ms) as avg_generation_time,
    AVG(quality_score) as avg_quality,
    MAX(created_at) as last_generated
FROM generated_insights
WHERE user_id = $1
  AND created_at >= $2
GROUP BY report_type
ORDER BY total_generated DESC
`

type GetInsightGenerationMetricsParams struct {
	UserID    uuid.UUID          `db:"user_id" json:"user_id"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type GetInsightGenerationMetricsRow struct {
	ReportType        string      `db:"report_type" json:"report_type"`
	TotalGenerated    int64       `db:"total_generated" json:"total_generated"`
	AvgGenerationTime float64     `db:"avg_generation_time" json:"avg_generation_time"`
	AvgQuality        float64     `db:"avg_quality" json:"avg_quality"`
	LastGenerated     interface{} `db:"last_generated" json:"last_generated"`
}

func (q *Queries) GetInsightGenerationMetrics(ctx context.Context, arg GetInsightGenerationMetricsParams) ([]GetInsightGenerationMetricsRow, error) {
	rows, err := q.db.Query(ctx, getInsightGenerationMetrics, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInsightGenerationMetricsRow{}
	for rows.Next() {
		var i GetInsightGenerationMetricsRow
		if err := rows.Scan(
			&i.ReportType,
			&i.TotalGenerated,
			&i.AvgGenerationTime,
			&i.AvgQuality,
			&i.LastGenerated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInsightStats = `-- name: GetInsightStats :one
SELECT
    COUNT(*) as total_insights,
    COUNT(CASE WHEN status = 'active' THEN 1 END) as active_insights,
    AVG(quality_score) as avg_quality_score,
    AVG(generation_duration_ms) as avg_generation_time
FROM generated_insights
WHERE user_id = $1
`

type GetInsightStatsRow struct {
	TotalInsights     int64   `db:"total_insights" json:"total_insights"`
	ActiveInsights    int64   `db:"active_insights" json:"active_insights"`
	AvgQualityScore   float64 `db:"avg_quality_score" json:"avg_quality_score"`
	AvgGenerationTime float64 `db:"avg_generation_time" json:"avg_generation_time"`
}

func (q *Queries) GetInsightStats(ctx context.Context, userID uuid.UUID) (GetInsightStatsRow, error) {
	row := q.db.QueryRow(ctx, getInsightStats, userID)
	var i GetInsightStatsRow
	err := row.Scan(
		&i.TotalInsights,
		&i.ActiveInsights,
		&i.AvgQualityScore,
		&i.AvgGenerationTime,
	)
	return i, err
}

const getInsightsByPeriod = `-- name: GetInsightsByPeriod :many
SELECT id, user_id, report_type, period_start, period_end, title, content, summary, metadata, generation_model, generation_duration_ms, quality_score, status, created_at, updated_at FROM generated_insights
WHERE user_id = $1
  AND period_start >= $2
  AND period_end <= $3
  AND status = 'active'
ORDER BY period_start DESC
`

type GetInsightsByPeriodParams struct {
	UserID      uuid.UUID   `db:"user_id" json:"user_id"`
	PeriodStart pgtype.Date `db:"period_start" json:"period_start"`
	PeriodEnd   pgtype.Date `db:"period_end" json:"period_end"`
}

func (q *Queries) GetInsightsByPeriod(ctx context.Context, arg GetInsightsByPeriodParams) ([]GeneratedInsight, error) {
	rows, err := q.db.Query(ctx, getInsightsByPeriod, arg.UserID, arg.PeriodStart, arg.PeriodEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GeneratedInsight{}
	for rows.Next() {
		var i GeneratedInsight
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ReportType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Title,
			&i.Content,
			&i.Summary,
			&i.Metadata,
			&i.GenerationModel,
			&i.GenerationDurationMs,
			&i.QualityScore,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInsightsByQuality = `-- name: GetInsightsByQuality :many
SELECT id, user_id, report_type, period_start, period_end, title, content, summary, metadata, generation_model, generation_duration_ms, quality_score, status, created_at, updated_at FROM generated_insights
WHERE user_id = $1
  AND quality_score >= $2
  AND status = 'active'
ORDER BY quality_score DESC, created_at DESC
`

type GetInsightsByQualityParams struct {
	UserID       uuid.UUID      `db:"user_id" json:"user_id"`
	QualityScore pgtype.Numeric `db:"quality_score" json:"quality_score"`
}

func (q *Queries) GetInsightsByQuality(ctx context.Context, arg GetInsightsByQualityParams) ([]GeneratedInsight, error) {
	rows, err := q.db.Query(ctx, getInsightsByQuality, arg.UserID, arg.QualityScore)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GeneratedInsight{}
	for rows.Next() {
		var i GeneratedInsight
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ReportType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Title,
			&i.Content,
			&i.Summary,
			&i.Metadata,
			&i.GenerationModel,
			&i.GenerationDurationMs,
			&i.QualityScore,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInsightsByUser = `-- name: GetInsightsByUser :many
SELECT id, user_id, report_type, period_start, period_end, title, content, summary, metadata, generation_model, generation_duration_ms, quality_score, status, created_at, updated_at FROM generated_insights
WHERE user_id = $1 AND status = 'active'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetInsightsByUserParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

func (q *Queries) GetInsightsByUser(ctx context.Context, arg GetInsightsByUserParams) ([]GeneratedInsight, error) {
	rows, err := q.db.Query(ctx, getInsightsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GeneratedInsight{}
	for rows.Next() {
		var i GeneratedInsight
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ReportType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Title,
			&i.Content,
			&i.Summary,
			&i.Metadata,
			&i.GenerationModel,
			&i.GenerationDurationMs,
			&i.QualityScore,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInsightsByUserAndType = `-- name: GetInsightsByUserAndType :many
SELECT id, user_id, report_type, period_start, period_end, title, content, summary, metadata, generation_model, generation_duration_ms, quality_score, status, created_at, updated_at FROM generated_insights
WHERE user_id = $1 AND report_type = $2 AND status = 'active'
ORDER BY created_at DESC
`

type GetInsightsByUserAndTypeParams struct {
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	ReportType string    `db:"report_type" json:"report_type"`
}

func (q *Queries) GetInsightsByUserAndType(ctx context.Context, arg GetInsightsByUserAndTypeParams) ([]GeneratedInsight, error) {
	rows, err := q.db.Query(ctx, getInsightsByUserAndType, arg.UserID, arg.ReportType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GeneratedInsight{}
	for rows.Next() {
		var i GeneratedInsight
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ReportType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Title,
			&i.Content,
			&i.Summary,
			&i.Metadata,
			&i.GenerationModel,
			&i.GenerationDurationMs,
			&i.QualityScore,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestInsightByType = `-- name: GetLatestInsightByType :one
SELECT id, user_id, report_type, period_start, period_end, title, content, summary, metadata, generation_model, generation_duration_ms, quality_score, status, created_at, updated_at FROM generated_insights
WHERE user_id = $1 AND report_type = $2 AND status = 'active'
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestInsightByTypeParams struct {
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	ReportType string    `db:"report_type" json:"report_type"`
}

func (q *Queries) GetLatestInsightByType(ctx context.Context, arg GetLatestInsightByTypeParams) (GeneratedInsight, error) {
	row := q.db.QueryRow(ctx, getLatestInsightByType, arg.UserID, arg.ReportType)
	var i GeneratedInsight
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ReportType,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.Title,
		&i.Content,
		&i.Summary,
		&i.Metadata,
		&i.GenerationModel,
		&i.GenerationDurationMs,
		&i.QualityScore,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const supersedeOldInsights = `-- name: SupersedeOldInsights :exec
UPDATE generated_insights
SET status = 'superseded', updated_at = NOW()
WHERE user_id = $1
  AND report_type = $2
  AND period_start = $3
  AND period_end = $4
  AND status = 'active'
  AND id != $5
`

type SupersedeOldInsightsParams struct {
	UserID      uuid.UUID   `db:"user_id" json:"user_id"`
	ReportType  string      `db:"report_type" json:"report_type"`
	PeriodStart pgtype.Date `db:"period_start" json:"period_start"`
	PeriodEnd   pgtype.Date `db:"period_end" json:"period_end"`
	ID          uuid.UUID   `db:"id" json:"id"`
}

func (q *Queries) SupersedeOldInsights(ctx context.Context, arg SupersedeOldInsightsParams) error {
	_, err := q.db.Exec(ctx, supersedeOldInsights,
		arg.UserID,
		arg.ReportType,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.ID,
	)
	return err
}

const updateInsight = `-- name: UpdateInsight :one
UPDATE generated_insights
SET title = $2, content = $3, summary = $4,
    metadata = $5, updated_at = NOW()
WHERE id = $1 AND user_id = $6
RETURNING id, user_id, report_type, period_start, period_end, title, content, summary, metadata, generation_model, generation_duration_ms, quality_score, status, created_at, updated_at
`

type UpdateInsightParams struct {
	ID       uuid.UUID   `db:"id" json:"id"`
	Title    string      `db:"title" json:"title"`
	Content  string      `db:"content" json:"content"`
	Summary  pgtype.Text `db:"summary" json:"summary"`
	Metadata []byte      `db:"metadata" json:"metadata"`
	UserID   uuid.UUID   `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateInsight(ctx context.Context, arg UpdateInsightParams) (GeneratedInsight, error) {
	row := q.db.QueryRow(ctx, updateInsight,
		arg.ID,
		arg.Title,
		arg.Content,
		arg.Summary,
		arg.Metadata,
		arg.UserID,
	)
	var i GeneratedInsight
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ReportType,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.Title,
		&i.Content,
		&i.Summary,
		&i.Metadata,
		&i.GenerationModel,
		&i.GenerationDurationMs,
		&i.QualityScore,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
