// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: auth.sql

package store

import (
	"context"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelDeletionRequest = `-- name: CancelDeletionRequest :exec
UPDATE scheduled_deletions
SET status = 'cancelled'
WHERE id = $1 AND user_id = $2 AND status = 'pending'
`

type CancelDeletionRequestParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) CancelDeletionRequest(ctx context.Context, arg CancelDeletionRequestParams) error {
	_, err := q.db.Exec(ctx, cancelDeletionRequest, arg.ID, arg.UserID)
	return err
}

const cleanupExpiredDenylistedTokens = `-- name: CleanupExpiredDenylistedTokens :exec
DELETE FROM refresh_token_denylist
WHERE expires_at < NOW() - INTERVAL '7 days'
`

func (q *Queries) CleanupExpiredDenylistedTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredDenylistedTokens)
	return err
}

const cleanupExpiredSessions = `-- name: CleanupExpiredSessions :exec
DELETE FROM user_sessions
WHERE expires_at < NOW()
`

func (q *Queries) CleanupExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredSessions)
	return err
}

const createRefreshTokenDenylist = `-- name: CreateRefreshTokenDenylist :exec

INSERT INTO refresh_token_denylist (jti, user_id, expires_at, reason)
VALUES ($1, $2, $3, COALESCE($4, 'logout'))
`

type CreateRefreshTokenDenylistParams struct {
	Jti       string             `db:"jti" json:"jti"`
	UserID    uuid.UUID          `db:"user_id" json:"user_id"`
	ExpiresAt pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	Column4   interface{}        `db:"column_4" json:"column_4"`
}

// EngLog Authentication Queries
// JWT token management and session handling
func (q *Queries) CreateRefreshTokenDenylist(ctx context.Context, arg CreateRefreshTokenDenylistParams) error {
	_, err := q.db.Exec(ctx, createRefreshTokenDenylist,
		arg.Jti,
		arg.UserID,
		arg.ExpiresAt,
		arg.Column4,
	)
	return err
}

const createUserSession = `-- name: CreateUserSession :one
INSERT INTO user_sessions (
    user_id, session_token_hash, refresh_token_hash,
    expires_at, ip_address, user_agent
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, session_token_hash, refresh_token_hash, expires_at, last_activity, ip_address, user_agent, is_active, created_at
`

type CreateUserSessionParams struct {
	UserID           uuid.UUID          `db:"user_id" json:"user_id"`
	SessionTokenHash string             `db:"session_token_hash" json:"session_token_hash"`
	RefreshTokenHash string             `db:"refresh_token_hash" json:"refresh_token_hash"`
	ExpiresAt        pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	IpAddress        *netip.Addr        `db:"ip_address" json:"ip_address"`
	UserAgent        pgtype.Text        `db:"user_agent" json:"user_agent"`
}

func (q *Queries) CreateUserSession(ctx context.Context, arg CreateUserSessionParams) (UserSession, error) {
	row := q.db.QueryRow(ctx, createUserSession,
		arg.UserID,
		arg.SessionTokenHash,
		arg.RefreshTokenHash,
		arg.ExpiresAt,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionTokenHash,
		&i.RefreshTokenHash,
		&i.ExpiresAt,
		&i.LastActivity,
		&i.IpAddress,
		&i.UserAgent,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateSession = `-- name: DeactivateSession :exec
UPDATE user_sessions
SET is_active = false
WHERE id = $1
`

func (q *Queries) DeactivateSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateSession, id)
	return err
}

const deactivateUserSessions = `-- name: DeactivateUserSessions :exec
UPDATE user_sessions
SET is_active = false
WHERE user_id = $1
`

func (q *Queries) DeactivateUserSessions(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateUserSessions, userID)
	return err
}

const getActiveSessionsByUser = `-- name: GetActiveSessionsByUser :many
SELECT id, user_id, session_token_hash, refresh_token_hash, expires_at, last_activity, ip_address, user_agent, is_active, created_at FROM user_sessions
WHERE user_id = $1 AND is_active = true
ORDER BY last_activity DESC
`

func (q *Queries) GetActiveSessionsByUser(ctx context.Context, userID uuid.UUID) ([]UserSession, error) {
	rows, err := q.db.Query(ctx, getActiveSessionsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSession{}
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionTokenHash,
			&i.RefreshTokenHash,
			&i.ExpiresAt,
			&i.LastActivity,
			&i.IpAddress,
			&i.UserAgent,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDenylistedTokensByUser = `-- name: GetDenylistedTokensByUser :many
SELECT jti, user_id, expires_at, denylisted_at, reason FROM refresh_token_denylist
WHERE user_id = $1
ORDER BY denylisted_at DESC
`

func (q *Queries) GetDenylistedTokensByUser(ctx context.Context, userID uuid.UUID) ([]RefreshTokenDenylist, error) {
	rows, err := q.db.Query(ctx, getDenylistedTokensByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefreshTokenDenylist{}
	for rows.Next() {
		var i RefreshTokenDenylist
		if err := rows.Scan(
			&i.Jti,
			&i.UserID,
			&i.ExpiresAt,
			&i.DenylistedAt,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduledDeletions = `-- name: GetScheduledDeletions :many
SELECT id, user_id, scheduled_at, deletion_type, status, completed_at, metadata, created_at FROM scheduled_deletions
WHERE status = 'pending'
  AND scheduled_at <= NOW()
ORDER BY scheduled_at ASC
`

func (q *Queries) GetScheduledDeletions(ctx context.Context) ([]ScheduledDeletion, error) {
	rows, err := q.db.Query(ctx, getScheduledDeletions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScheduledDeletion{}
	for rows.Next() {
		var i ScheduledDeletion
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ScheduledAt,
			&i.DeletionType,
			&i.Status,
			&i.CompletedAt,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionCount = `-- name: GetSessionCount :one
SELECT COUNT(*) FROM user_sessions
WHERE is_active = true
`

func (q *Queries) GetSessionCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getSessionCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserDeletionRequests = `-- name: GetUserDeletionRequests :many
SELECT id, user_id, scheduled_at, deletion_type, status, completed_at, metadata, created_at FROM scheduled_deletions
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetUserDeletionRequests(ctx context.Context, userID uuid.UUID) ([]ScheduledDeletion, error) {
	rows, err := q.db.Query(ctx, getUserDeletionRequests, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScheduledDeletion{}
	for rows.Next() {
		var i ScheduledDeletion
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ScheduledAt,
			&i.DeletionType,
			&i.Status,
			&i.CompletedAt,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSession = `-- name: GetUserSession :one
SELECT id, user_id, session_token_hash, refresh_token_hash, expires_at, last_activity, ip_address, user_agent, is_active, created_at FROM user_sessions
WHERE id = $1 AND is_active = true
`

func (q *Queries) GetUserSession(ctx context.Context, id uuid.UUID) (UserSession, error) {
	row := q.db.QueryRow(ctx, getUserSession, id)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionTokenHash,
		&i.RefreshTokenHash,
		&i.ExpiresAt,
		&i.LastActivity,
		&i.IpAddress,
		&i.UserAgent,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getUserSessionByToken = `-- name: GetUserSessionByToken :one
SELECT id, user_id, session_token_hash, refresh_token_hash, expires_at, last_activity, ip_address, user_agent, is_active, created_at FROM user_sessions
WHERE session_token_hash = $1 AND is_active = true
`

func (q *Queries) GetUserSessionByToken(ctx context.Context, sessionTokenHash string) (UserSession, error) {
	row := q.db.QueryRow(ctx, getUserSessionByToken, sessionTokenHash)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionTokenHash,
		&i.RefreshTokenHash,
		&i.ExpiresAt,
		&i.LastActivity,
		&i.IpAddress,
		&i.UserAgent,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const isRefreshTokenDenylisted = `-- name: IsRefreshTokenDenylisted :one
SELECT EXISTS(
    SELECT 1 FROM refresh_token_denylist
    WHERE jti = $1
)
`

func (q *Queries) IsRefreshTokenDenylisted(ctx context.Context, jti string) (bool, error) {
	row := q.db.QueryRow(ctx, isRefreshTokenDenylisted, jti)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const scheduleUserDeletion = `-- name: ScheduleUserDeletion :one
INSERT INTO scheduled_deletions (
    user_id, scheduled_at, deletion_type, metadata
) VALUES (
    $1, $2, $3, $4
) RETURNING id, user_id, scheduled_at, deletion_type, status, completed_at, metadata, created_at
`

type ScheduleUserDeletionParams struct {
	UserID       uuid.UUID          `db:"user_id" json:"user_id"`
	ScheduledAt  pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
	DeletionType string             `db:"deletion_type" json:"deletion_type"`
	Metadata     []byte             `db:"metadata" json:"metadata"`
}

func (q *Queries) ScheduleUserDeletion(ctx context.Context, arg ScheduleUserDeletionParams) (ScheduledDeletion, error) {
	row := q.db.QueryRow(ctx, scheduleUserDeletion,
		arg.UserID,
		arg.ScheduledAt,
		arg.DeletionType,
		arg.Metadata,
	)
	var i ScheduledDeletion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ScheduledAt,
		&i.DeletionType,
		&i.Status,
		&i.CompletedAt,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const updateDeletionStatus = `-- name: UpdateDeletionStatus :exec
UPDATE scheduled_deletions
SET status = $2, completed_at = CASE WHEN $2 = 'completed' THEN NOW() ELSE completed_at END
WHERE id = $1
`

type UpdateDeletionStatusParams struct {
	ID     uuid.UUID   `db:"id" json:"id"`
	Status pgtype.Text `db:"status" json:"status"`
}

func (q *Queries) UpdateDeletionStatus(ctx context.Context, arg UpdateDeletionStatusParams) error {
	_, err := q.db.Exec(ctx, updateDeletionStatus, arg.ID, arg.Status)
	return err
}

const updateSessionActivity = `-- name: UpdateSessionActivity :exec
UPDATE user_sessions
SET last_activity = NOW()
WHERE id = $1
`

func (q *Queries) UpdateSessionActivity(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateSessionActivity, id)
	return err
}
