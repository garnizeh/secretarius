// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: analytics.sql

package store

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getActivityTypeDistribution = `-- name: GetActivityTypeDistribution :many
SELECT
    type,
    COUNT(*) as entry_count,
    SUM(duration_minutes) as total_minutes,
    AVG(duration_minutes) as avg_duration,
    ROUND(AVG(CASE
        WHEN value_rating = 'critical' THEN 4
        WHEN value_rating = 'high' THEN 3
        WHEN value_rating = 'medium' THEN 2
        WHEN value_rating = 'low' THEN 1
        ELSE 0
    END), 2) as avg_value_score
FROM log_entries
WHERE user_id = $1
  AND start_time >= $2
  AND start_time <= $3
GROUP BY type
ORDER BY total_minutes DESC
`

type GetActivityTypeDistributionParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StartTime_2 pgtype.Timestamptz `db:"start_time_2" json:"start_time_2"`
}

type GetActivityTypeDistributionRow struct {
	Type          string         `db:"type" json:"type"`
	EntryCount    int64          `db:"entry_count" json:"entry_count"`
	TotalMinutes  int64          `db:"total_minutes" json:"total_minutes"`
	AvgDuration   float64        `db:"avg_duration" json:"avg_duration"`
	AvgValueScore pgtype.Numeric `db:"avg_value_score" json:"avg_value_score"`
}

func (q *Queries) GetActivityTypeDistribution(ctx context.Context, arg GetActivityTypeDistributionParams) ([]GetActivityTypeDistributionRow, error) {
	rows, err := q.db.Query(ctx, getActivityTypeDistribution, arg.UserID, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActivityTypeDistributionRow{}
	for rows.Next() {
		var i GetActivityTypeDistributionRow
		if err := rows.Scan(
			&i.Type,
			&i.EntryCount,
			&i.TotalMinutes,
			&i.AvgDuration,
			&i.AvgValueScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComparisonStats = `-- name: GetComparisonStats :one
SELECT
    -- Current period
    COUNT(CASE WHEN start_time >= $2 AND start_time <= $3 THEN 1 END) as current_entries,
    SUM(CASE WHEN start_time >= $2 AND start_time <= $3 THEN duration_minutes ELSE 0 END) as current_minutes,

    -- Previous period
    COUNT(CASE WHEN start_time >= $4 AND start_time <= $5 THEN 1 END) as previous_entries,
    SUM(CASE WHEN start_time >= $4 AND start_time <= $5 THEN duration_minutes ELSE 0 END) as previous_minutes
FROM log_entries
WHERE user_id = $1
`

type GetComparisonStatsParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StartTime_2 pgtype.Timestamptz `db:"start_time_2" json:"start_time_2"`
	StartTime_3 pgtype.Timestamptz `db:"start_time_3" json:"start_time_3"`
	StartTime_4 pgtype.Timestamptz `db:"start_time_4" json:"start_time_4"`
}

type GetComparisonStatsRow struct {
	CurrentEntries  int64 `db:"current_entries" json:"current_entries"`
	CurrentMinutes  int64 `db:"current_minutes" json:"current_minutes"`
	PreviousEntries int64 `db:"previous_entries" json:"previous_entries"`
	PreviousMinutes int64 `db:"previous_minutes" json:"previous_minutes"`
}

func (q *Queries) GetComparisonStats(ctx context.Context, arg GetComparisonStatsParams) (GetComparisonStatsRow, error) {
	row := q.db.QueryRow(ctx, getComparisonStats,
		arg.UserID,
		arg.StartTime,
		arg.StartTime_2,
		arg.StartTime_3,
		arg.StartTime_4,
	)
	var i GetComparisonStatsRow
	err := row.Scan(
		&i.CurrentEntries,
		&i.CurrentMinutes,
		&i.PreviousEntries,
		&i.PreviousMinutes,
	)
	return i, err
}

const getDailyActivityPattern = `-- name: GetDailyActivityPattern :many
SELECT user_id, activity_date, day_of_week, hour_of_day, entry_count, total_minutes, avg_duration, activity_types, avg_value_score FROM daily_activity_patterns
WHERE user_id = $1
  AND activity_date >= $2
  AND activity_date <= $3
ORDER BY activity_date DESC, hour_of_day ASC
`

type GetDailyActivityPatternParams struct {
	UserID         uuid.UUID   `db:"user_id" json:"user_id"`
	ActivityDate   pgtype.Date `db:"activity_date" json:"activity_date"`
	ActivityDate_2 pgtype.Date `db:"activity_date_2" json:"activity_date_2"`
}

func (q *Queries) GetDailyActivityPattern(ctx context.Context, arg GetDailyActivityPatternParams) ([]DailyActivityPattern, error) {
	rows, err := q.db.Query(ctx, getDailyActivityPattern, arg.UserID, arg.ActivityDate, arg.ActivityDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DailyActivityPattern{}
	for rows.Next() {
		var i DailyActivityPattern
		if err := rows.Scan(
			&i.UserID,
			&i.ActivityDate,
			&i.DayOfWeek,
			&i.HourOfDay,
			&i.EntryCount,
			&i.TotalMinutes,
			&i.AvgDuration,
			&i.ActivityTypes,
			&i.AvgValueScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImpactLevelDistribution = `-- name: GetImpactLevelDistribution :many
SELECT
    impact_level,
    COUNT(*) as entry_count,
    SUM(duration_minutes) as total_minutes,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) as percentage
FROM log_entries
WHERE user_id = $1
  AND start_time >= $2
  AND start_time <= $3
GROUP BY impact_level
ORDER BY CASE impact_level
    WHEN 'company' THEN 4
    WHEN 'department' THEN 3
    WHEN 'team' THEN 2
    WHEN 'personal' THEN 1
    ELSE 0
END DESC
`

type GetImpactLevelDistributionParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StartTime_2 pgtype.Timestamptz `db:"start_time_2" json:"start_time_2"`
}

type GetImpactLevelDistributionRow struct {
	ImpactLevel  string         `db:"impact_level" json:"impact_level"`
	EntryCount   int64          `db:"entry_count" json:"entry_count"`
	TotalMinutes int64          `db:"total_minutes" json:"total_minutes"`
	Percentage   pgtype.Numeric `db:"percentage" json:"percentage"`
}

func (q *Queries) GetImpactLevelDistribution(ctx context.Context, arg GetImpactLevelDistributionParams) ([]GetImpactLevelDistributionRow, error) {
	rows, err := q.db.Query(ctx, getImpactLevelDistribution, arg.UserID, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetImpactLevelDistributionRow{}
	for rows.Next() {
		var i GetImpactLevelDistributionRow
		if err := rows.Scan(
			&i.ImpactLevel,
			&i.EntryCount,
			&i.TotalMinutes,
			&i.Percentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyActivitySummary = `-- name: GetMonthlyActivitySummary :many
SELECT
    DATE_TRUNC('month', start_time) as month_start,
    COUNT(*) as entry_count,
    SUM(duration_minutes) as total_minutes,
    AVG(duration_minutes) as avg_duration,
    COUNT(DISTINCT project_id) as projects_count,
    COUNT(DISTINCT DATE(start_time)) as active_days
FROM log_entries
WHERE user_id = $1
  AND start_time >= $2
  AND start_time <= $3
GROUP BY DATE_TRUNC('month', start_time)
ORDER BY month_start DESC
`

type GetMonthlyActivitySummaryParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StartTime_2 pgtype.Timestamptz `db:"start_time_2" json:"start_time_2"`
}

type GetMonthlyActivitySummaryRow struct {
	MonthStart    pgtype.Interval `db:"month_start" json:"month_start"`
	EntryCount    int64           `db:"entry_count" json:"entry_count"`
	TotalMinutes  int64           `db:"total_minutes" json:"total_minutes"`
	AvgDuration   float64         `db:"avg_duration" json:"avg_duration"`
	ProjectsCount int64           `db:"projects_count" json:"projects_count"`
	ActiveDays    int64           `db:"active_days" json:"active_days"`
}

func (q *Queries) GetMonthlyActivitySummary(ctx context.Context, arg GetMonthlyActivitySummaryParams) ([]GetMonthlyActivitySummaryRow, error) {
	rows, err := q.db.Query(ctx, getMonthlyActivitySummary, arg.UserID, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMonthlyActivitySummaryRow{}
	for rows.Next() {
		var i GetMonthlyActivitySummaryRow
		if err := rows.Scan(
			&i.MonthStart,
			&i.EntryCount,
			&i.TotalMinutes,
			&i.AvgDuration,
			&i.ProjectsCount,
			&i.ActiveDays,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductivityByDayOfWeek = `-- name: GetProductivityByDayOfWeek :many
SELECT
    EXTRACT(DOW FROM start_time) as day_of_week,
    TO_CHAR(start_time, 'Day') as day_name,
    COUNT(*) as entry_count,
    SUM(duration_minutes) as total_minutes,
    AVG(duration_minutes) as avg_duration
FROM log_entries
WHERE user_id = $1
  AND start_time >= $2
  AND start_time <= $3
GROUP BY EXTRACT(DOW FROM start_time), TO_CHAR(start_time, 'Day')
ORDER BY day_of_week
`

type GetProductivityByDayOfWeekParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StartTime_2 pgtype.Timestamptz `db:"start_time_2" json:"start_time_2"`
}

type GetProductivityByDayOfWeekRow struct {
	DayOfWeek    pgtype.Numeric `db:"day_of_week" json:"day_of_week"`
	DayName      string         `db:"day_name" json:"day_name"`
	EntryCount   int64          `db:"entry_count" json:"entry_count"`
	TotalMinutes int64          `db:"total_minutes" json:"total_minutes"`
	AvgDuration  float64        `db:"avg_duration" json:"avg_duration"`
}

func (q *Queries) GetProductivityByDayOfWeek(ctx context.Context, arg GetProductivityByDayOfWeekParams) ([]GetProductivityByDayOfWeekRow, error) {
	rows, err := q.db.Query(ctx, getProductivityByDayOfWeek, arg.UserID, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductivityByDayOfWeekRow{}
	for rows.Next() {
		var i GetProductivityByDayOfWeekRow
		if err := rows.Scan(
			&i.DayOfWeek,
			&i.DayName,
			&i.EntryCount,
			&i.TotalMinutes,
			&i.AvgDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductivityByHour = `-- name: GetProductivityByHour :many
SELECT
    EXTRACT(HOUR FROM start_time) as hour_of_day,
    COUNT(*) as entry_count,
    SUM(duration_minutes) as total_minutes,
    AVG(duration_minutes) as avg_duration
FROM log_entries
WHERE user_id = $1
  AND start_time >= $2
  AND start_time <= $3
GROUP BY EXTRACT(HOUR FROM start_time)
ORDER BY hour_of_day
`

type GetProductivityByHourParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StartTime_2 pgtype.Timestamptz `db:"start_time_2" json:"start_time_2"`
}

type GetProductivityByHourRow struct {
	HourOfDay    pgtype.Numeric `db:"hour_of_day" json:"hour_of_day"`
	EntryCount   int64          `db:"entry_count" json:"entry_count"`
	TotalMinutes int64          `db:"total_minutes" json:"total_minutes"`
	AvgDuration  float64        `db:"avg_duration" json:"avg_duration"`
}

func (q *Queries) GetProductivityByHour(ctx context.Context, arg GetProductivityByHourParams) ([]GetProductivityByHourRow, error) {
	rows, err := q.db.Query(ctx, getProductivityByHour, arg.UserID, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductivityByHourRow{}
	for rows.Next() {
		var i GetProductivityByHourRow
		if err := rows.Scan(
			&i.HourOfDay,
			&i.EntryCount,
			&i.TotalMinutes,
			&i.AvgDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectPerformanceMetrics = `-- name: GetProjectPerformanceMetrics :many
SELECT project_id, project_name, project_status, project_owner, total_entries, total_minutes, avg_entry_duration, contributors_count, active_days, first_activity, last_activity, avg_value_score, most_common_activity, recent_entries_30d, project_created_at FROM project_performance_metrics
WHERE project_owner = $1
ORDER BY total_minutes DESC
`

func (q *Queries) GetProjectPerformanceMetrics(ctx context.Context, projectOwner uuid.UUID) ([]ProjectPerformanceMetric, error) {
	rows, err := q.db.Query(ctx, getProjectPerformanceMetrics, projectOwner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectPerformanceMetric{}
	for rows.Next() {
		var i ProjectPerformanceMetric
		if err := rows.Scan(
			&i.ProjectID,
			&i.ProjectName,
			&i.ProjectStatus,
			&i.ProjectOwner,
			&i.TotalEntries,
			&i.TotalMinutes,
			&i.AvgEntryDuration,
			&i.ContributorsCount,
			&i.ActiveDays,
			&i.FirstActivity,
			&i.LastActivity,
			&i.AvgValueScore,
			&i.MostCommonActivity,
			&i.RecentEntries30d,
			&i.ProjectCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopProjectsByTime = `-- name: GetTopProjectsByTime :many
SELECT
    p.id, p.name, p.color,
    COUNT(le.id) as entry_count,
    SUM(le.duration_minutes) as total_minutes,
    ROUND(SUM(le.duration_minutes) * 100.0 / SUM(SUM(le.duration_minutes)) OVER (), 2) as percentage
FROM log_entries le
JOIN projects p ON le.project_id = p.id
WHERE le.user_id = $1
  AND le.start_time >= $2
  AND le.start_time <= $3
GROUP BY p.id, p.name, p.color
ORDER BY total_minutes DESC
LIMIT $4
`

type GetTopProjectsByTimeParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StartTime_2 pgtype.Timestamptz `db:"start_time_2" json:"start_time_2"`
	Limit       int32              `db:"limit" json:"limit"`
}

type GetTopProjectsByTimeRow struct {
	ID           uuid.UUID      `db:"id" json:"id"`
	Name         string         `db:"name" json:"name"`
	Color        pgtype.Text    `db:"color" json:"color"`
	EntryCount   int64          `db:"entry_count" json:"entry_count"`
	TotalMinutes int64          `db:"total_minutes" json:"total_minutes"`
	Percentage   pgtype.Numeric `db:"percentage" json:"percentage"`
}

func (q *Queries) GetTopProjectsByTime(ctx context.Context, arg GetTopProjectsByTimeParams) ([]GetTopProjectsByTimeRow, error) {
	rows, err := q.db.Query(ctx, getTopProjectsByTime,
		arg.UserID,
		arg.StartTime,
		arg.StartTime_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopProjectsByTimeRow{}
	for rows.Next() {
		var i GetTopProjectsByTimeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.EntryCount,
			&i.TotalMinutes,
			&i.Percentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActivitySummaryView = `-- name: GetUserActivitySummaryView :one

SELECT user_id, email, timezone, total_entries, total_minutes, avg_duration_minutes, projects_count, active_days, first_entry_date, last_entry_date, critical_entries, high_entries, medium_entries, low_entries, company_impact_entries, department_impact_entries, team_impact_entries, personal_impact_entries, development_entries, meeting_entries, review_entries, debugging_entries, activity_span_days, recent_entries_30d, recent_minutes_30d, refreshed_at FROM user_activity_summary
WHERE user_id = $1
`

// EngLog Analytics Queries
// Advanced analytics and reporting
func (q *Queries) GetUserActivitySummaryView(ctx context.Context, userID uuid.UUID) (UserActivitySummary, error) {
	row := q.db.QueryRow(ctx, getUserActivitySummaryView, userID)
	var i UserActivitySummary
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Timezone,
		&i.TotalEntries,
		&i.TotalMinutes,
		&i.AvgDurationMinutes,
		&i.ProjectsCount,
		&i.ActiveDays,
		&i.FirstEntryDate,
		&i.LastEntryDate,
		&i.CriticalEntries,
		&i.HighEntries,
		&i.MediumEntries,
		&i.LowEntries,
		&i.CompanyImpactEntries,
		&i.DepartmentImpactEntries,
		&i.TeamImpactEntries,
		&i.PersonalImpactEntries,
		&i.DevelopmentEntries,
		&i.MeetingEntries,
		&i.ReviewEntries,
		&i.DebuggingEntries,
		&i.ActivitySpanDays,
		&i.RecentEntries30d,
		&i.RecentMinutes30d,
		&i.RefreshedAt,
	)
	return i, err
}

const getUserProductivityTrend = `-- name: GetUserProductivityTrend :many
SELECT get_user_productivity_trend FROM get_user_productivity_trend($1, $2)
`

type GetUserProductivityTrendParams struct {
	UserUuid uuid.UUID `db:"user_uuid" json:"user_uuid"`
	DaysBack int32     `db:"days_back" json:"days_back"`
}

func (q *Queries) GetUserProductivityTrend(ctx context.Context, arg GetUserProductivityTrendParams) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, getUserProductivityTrend, arg.UserUuid, arg.DaysBack)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []interface{}{}
	for rows.Next() {
		var get_user_productivity_trend interface{}
		if err := rows.Scan(&get_user_productivity_trend); err != nil {
			return nil, err
		}
		items = append(items, get_user_productivity_trend)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValueRatingDistribution = `-- name: GetValueRatingDistribution :many
SELECT
    value_rating,
    COUNT(*) as entry_count,
    SUM(duration_minutes) as total_minutes,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) as percentage
FROM log_entries
WHERE user_id = $1
  AND start_time >= $2
  AND start_time <= $3
GROUP BY value_rating
ORDER BY CASE value_rating
    WHEN 'critical' THEN 4
    WHEN 'high' THEN 3
    WHEN 'medium' THEN 2
    WHEN 'low' THEN 1
    ELSE 0
END DESC
`

type GetValueRatingDistributionParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StartTime_2 pgtype.Timestamptz `db:"start_time_2" json:"start_time_2"`
}

type GetValueRatingDistributionRow struct {
	ValueRating  string         `db:"value_rating" json:"value_rating"`
	EntryCount   int64          `db:"entry_count" json:"entry_count"`
	TotalMinutes int64          `db:"total_minutes" json:"total_minutes"`
	Percentage   pgtype.Numeric `db:"percentage" json:"percentage"`
}

func (q *Queries) GetValueRatingDistribution(ctx context.Context, arg GetValueRatingDistributionParams) ([]GetValueRatingDistributionRow, error) {
	rows, err := q.db.Query(ctx, getValueRatingDistribution, arg.UserID, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetValueRatingDistributionRow{}
	for rows.Next() {
		var i GetValueRatingDistributionRow
		if err := rows.Scan(
			&i.ValueRating,
			&i.EntryCount,
			&i.TotalMinutes,
			&i.Percentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklyActivitySummary = `-- name: GetWeeklyActivitySummary :many
SELECT
    DATE_TRUNC('week', start_time) as week_start,
    COUNT(*) as entry_count,
    SUM(duration_minutes) as total_minutes,
    AVG(duration_minutes) as avg_duration,
    COUNT(DISTINCT project_id) as projects_count,
    COUNT(DISTINCT DATE(start_time)) as active_days
FROM log_entries
WHERE user_id = $1
  AND start_time >= $2
  AND start_time <= $3
GROUP BY DATE_TRUNC('week', start_time)
ORDER BY week_start DESC
`

type GetWeeklyActivitySummaryParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StartTime_2 pgtype.Timestamptz `db:"start_time_2" json:"start_time_2"`
}

type GetWeeklyActivitySummaryRow struct {
	WeekStart     pgtype.Interval `db:"week_start" json:"week_start"`
	EntryCount    int64           `db:"entry_count" json:"entry_count"`
	TotalMinutes  int64           `db:"total_minutes" json:"total_minutes"`
	AvgDuration   float64         `db:"avg_duration" json:"avg_duration"`
	ProjectsCount int64           `db:"projects_count" json:"projects_count"`
	ActiveDays    int64           `db:"active_days" json:"active_days"`
}

func (q *Queries) GetWeeklyActivitySummary(ctx context.Context, arg GetWeeklyActivitySummaryParams) ([]GetWeeklyActivitySummaryRow, error) {
	rows, err := q.db.Query(ctx, getWeeklyActivitySummary, arg.UserID, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWeeklyActivitySummaryRow{}
	for rows.Next() {
		var i GetWeeklyActivitySummaryRow
		if err := rows.Scan(
			&i.WeekStart,
			&i.EntryCount,
			&i.TotalMinutes,
			&i.AvgDuration,
			&i.ProjectsCount,
			&i.ActiveDays,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshUserActivitySummary = `-- name: RefreshUserActivitySummary :exec
REFRESH MATERIALIZED VIEW user_activity_summary
`

func (q *Queries) RefreshUserActivitySummary(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshUserActivitySummary)
	return err
}
