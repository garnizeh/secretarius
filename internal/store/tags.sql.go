// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tags.sql

package store

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addTagToLogEntry = `-- name: AddTagToLogEntry :exec
INSERT INTO log_entry_tags (log_entry_id, tag_id)
VALUES ($1, $2)
ON CONFLICT (log_entry_id, tag_id) DO NOTHING
`

type AddTagToLogEntryParams struct {
	LogEntryID uuid.UUID `db:"log_entry_id" json:"log_entry_id"`
	TagID      uuid.UUID `db:"tag_id" json:"tag_id"`
}

func (q *Queries) AddTagToLogEntry(ctx context.Context, arg AddTagToLogEntryParams) error {
	_, err := q.db.Exec(ctx, addTagToLogEntry, arg.LogEntryID, arg.TagID)
	return err
}

const cleanupUnusedTags = `-- name: CleanupUnusedTags :exec
DELETE FROM tags
WHERE usage_count = 0
  AND created_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) CleanupUnusedTags(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupUnusedTags)
	return err
}

const createTag = `-- name: CreateTag :one

INSERT INTO tags (name, color, description)
VALUES ($1, $2, $3)
RETURNING id, name, color, description, usage_count, created_at
`

type CreateTagParams struct {
	Name        string      `db:"name" json:"name"`
	Color       pgtype.Text `db:"color" json:"color"`
	Description pgtype.Text `db:"description" json:"description"`
}

// EngLog Tags Management Queries
// Tag CRUD operations and usage statistics
func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (Tag, error) {
	row := q.db.QueryRow(ctx, createTag, arg.Name, arg.Color, arg.Description)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Color,
		&i.Description,
		&i.UsageCount,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags
WHERE id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTag, id)
	return err
}

const getAllTags = `-- name: GetAllTags :many
SELECT id, name, color, description, usage_count, created_at FROM tags
ORDER BY usage_count DESC, name ASC
`

func (q *Queries) GetAllTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.Description,
			&i.UsageCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogEntriesForTag = `-- name: GetLogEntriesForTag :many
SELECT le.id, le.user_id, le.project_id, le.title, le.description, le.type, le.start_time, le.end_time, le.duration_minutes, le.value_rating, le.impact_level, le.created_at, le.updated_at FROM log_entries le
JOIN log_entry_tags let ON le.id = let.log_entry_id
WHERE let.tag_id = $1
ORDER BY le.start_time DESC
`

func (q *Queries) GetLogEntriesForTag(ctx context.Context, tagID uuid.UUID) ([]LogEntry, error) {
	rows, err := q.db.Query(ctx, getLogEntriesForTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogEntry{}
	for rows.Next() {
		var i LogEntry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.ValueRating,
			&i.ImpactLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularTags = `-- name: GetPopularTags :many
SELECT id, name, color, description, usage_count, created_at FROM tags
WHERE usage_count > 0
ORDER BY usage_count DESC, name ASC
LIMIT $1
`

func (q *Queries) GetPopularTags(ctx context.Context, limit int32) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getPopularTags, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.Description,
			&i.UsageCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentlyUsedTags = `-- name: GetRecentlyUsedTags :many
SELECT DISTINCT t.id, t.name, t.color, t.description, t.usage_count, t.created_at, MAX(le.created_at) as last_used
FROM tags t
JOIN log_entry_tags let ON t.id = let.tag_id
JOIN log_entries le ON let.log_entry_id = le.id
WHERE le.user_id = $1
  AND le.created_at >= $2
GROUP BY t.id, t.name, t.color, t.description, t.usage_count, t.created_at
ORDER BY last_used DESC
`

type GetRecentlyUsedTagsParams struct {
	UserID    uuid.UUID          `db:"user_id" json:"user_id"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type GetRecentlyUsedTagsRow struct {
	ID          uuid.UUID          `db:"id" json:"id"`
	Name        string             `db:"name" json:"name"`
	Color       pgtype.Text        `db:"color" json:"color"`
	Description pgtype.Text        `db:"description" json:"description"`
	UsageCount  pgtype.Int4        `db:"usage_count" json:"usage_count"`
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
	LastUsed    interface{}        `db:"last_used" json:"last_used"`
}

func (q *Queries) GetRecentlyUsedTags(ctx context.Context, arg GetRecentlyUsedTagsParams) ([]GetRecentlyUsedTagsRow, error) {
	rows, err := q.db.Query(ctx, getRecentlyUsedTags, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentlyUsedTagsRow{}
	for rows.Next() {
		var i GetRecentlyUsedTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.Description,
			&i.UsageCount,
			&i.CreatedAt,
			&i.LastUsed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByID = `-- name: GetTagByID :one
SELECT id, name, color, description, usage_count, created_at FROM tags
WHERE id = $1
`

func (q *Queries) GetTagByID(ctx context.Context, id uuid.UUID) (Tag, error) {
	row := q.db.QueryRow(ctx, getTagByID, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Color,
		&i.Description,
		&i.UsageCount,
		&i.CreatedAt,
	)
	return i, err
}

const getTagByName = `-- name: GetTagByName :one
SELECT id, name, color, description, usage_count, created_at FROM tags
WHERE name = $1
`

func (q *Queries) GetTagByName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, getTagByName, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Color,
		&i.Description,
		&i.UsageCount,
		&i.CreatedAt,
	)
	return i, err
}

const getTagUsageStats = `-- name: GetTagUsageStats :one
SELECT
    COUNT(*) as total_tags,
    COUNT(CASE WHEN usage_count > 0 THEN 1 END) as used_tags,
    AVG(usage_count) as avg_usage,
    MAX(usage_count) as max_usage
FROM tags
`

type GetTagUsageStatsRow struct {
	TotalTags int64       `db:"total_tags" json:"total_tags"`
	UsedTags  int64       `db:"used_tags" json:"used_tags"`
	AvgUsage  float64     `db:"avg_usage" json:"avg_usage"`
	MaxUsage  interface{} `db:"max_usage" json:"max_usage"`
}

func (q *Queries) GetTagUsageStats(ctx context.Context) (GetTagUsageStatsRow, error) {
	row := q.db.QueryRow(ctx, getTagUsageStats)
	var i GetTagUsageStatsRow
	err := row.Scan(
		&i.TotalTags,
		&i.UsedTags,
		&i.AvgUsage,
		&i.MaxUsage,
	)
	return i, err
}

const getTagsForLogEntry = `-- name: GetTagsForLogEntry :many
SELECT t.id, t.name, t.color, t.description, t.usage_count, t.created_at FROM tags t
JOIN log_entry_tags let ON t.id = let.tag_id
WHERE let.log_entry_id = $1
ORDER BY t.name
`

func (q *Queries) GetTagsForLogEntry(ctx context.Context, logEntryID uuid.UUID) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getTagsForLogEntry, logEntryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.Description,
			&i.UsageCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTagUsage = `-- name: GetUserTagUsage :many
SELECT
    t.id, t.name, t.color, t.description,
    COUNT(let.log_entry_id) as user_usage_count
FROM tags t
LEFT JOIN log_entry_tags let ON t.id = let.tag_id
LEFT JOIN log_entries le ON let.log_entry_id = le.id AND le.user_id = $1
GROUP BY t.id, t.name, t.color, t.description
HAVING COUNT(let.log_entry_id) > 0
ORDER BY user_usage_count DESC, t.name ASC
`

type GetUserTagUsageRow struct {
	ID             uuid.UUID   `db:"id" json:"id"`
	Name           string      `db:"name" json:"name"`
	Color          pgtype.Text `db:"color" json:"color"`
	Description    pgtype.Text `db:"description" json:"description"`
	UserUsageCount int64       `db:"user_usage_count" json:"user_usage_count"`
}

func (q *Queries) GetUserTagUsage(ctx context.Context, userID uuid.UUID) ([]GetUserTagUsageRow, error) {
	rows, err := q.db.Query(ctx, getUserTagUsage, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserTagUsageRow{}
	for rows.Next() {
		var i GetUserTagUsageRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.Description,
			&i.UserUsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTagFromLogEntry = `-- name: RemoveTagFromLogEntry :exec
DELETE FROM log_entry_tags
WHERE log_entry_id = $1 AND tag_id = $2
`

type RemoveTagFromLogEntryParams struct {
	LogEntryID uuid.UUID `db:"log_entry_id" json:"log_entry_id"`
	TagID      uuid.UUID `db:"tag_id" json:"tag_id"`
}

func (q *Queries) RemoveTagFromLogEntry(ctx context.Context, arg RemoveTagFromLogEntryParams) error {
	_, err := q.db.Exec(ctx, removeTagFromLogEntry, arg.LogEntryID, arg.TagID)
	return err
}

const searchTags = `-- name: SearchTags :many
SELECT id, name, color, description, usage_count, created_at FROM tags
WHERE name ILIKE '%' || $1 || '%'
ORDER BY usage_count DESC, name ASC
LIMIT $2
`

type SearchTagsParams struct {
	Column1 pgtype.Text `db:"column_1" json:"column_1"`
	Limit   int32       `db:"limit" json:"limit"`
}

func (q *Queries) SearchTags(ctx context.Context, arg SearchTagsParams) ([]Tag, error) {
	rows, err := q.db.Query(ctx, searchTags, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.Description,
			&i.UsageCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTag = `-- name: UpdateTag :one
UPDATE tags
SET name = $2, color = $3, description = $4
WHERE id = $1
RETURNING id, name, color, description, usage_count, created_at
`

type UpdateTagParams struct {
	ID          uuid.UUID   `db:"id" json:"id"`
	Name        string      `db:"name" json:"name"`
	Color       pgtype.Text `db:"color" json:"color"`
	Description pgtype.Text `db:"description" json:"description"`
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (Tag, error) {
	row := q.db.QueryRow(ctx, updateTag,
		arg.ID,
		arg.Name,
		arg.Color,
		arg.Description,
	)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Color,
		&i.Description,
		&i.UsageCount,
		&i.CreatedAt,
	)
	return i, err
}
