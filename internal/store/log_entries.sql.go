// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: log_entries.sql

package store

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createLogEntry = `-- name: CreateLogEntry :one

INSERT INTO log_entries (
    user_id, project_id, title, description, type,
    start_time, end_time, value_rating, impact_level
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, user_id, project_id, title, description, type, start_time, end_time, duration_minutes, value_rating, impact_level, created_at, updated_at
`

type CreateLogEntryParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	ProjectID   pgtype.UUID        `db:"project_id" json:"project_id"`
	Title       string             `db:"title" json:"title"`
	Description pgtype.Text        `db:"description" json:"description"`
	Type        string             `db:"type" json:"type"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	EndTime     pgtype.Timestamptz `db:"end_time" json:"end_time"`
	ValueRating string             `db:"value_rating" json:"value_rating"`
	ImpactLevel string             `db:"impact_level" json:"impact_level"`
}

// EngLog Log Entries Queries
// Activity tracking and log entry management
func (q *Queries) CreateLogEntry(ctx context.Context, arg CreateLogEntryParams) (LogEntry, error) {
	row := q.db.QueryRow(ctx, createLogEntry,
		arg.UserID,
		arg.ProjectID,
		arg.Title,
		arg.Description,
		arg.Type,
		arg.StartTime,
		arg.EndTime,
		arg.ValueRating,
		arg.ImpactLevel,
	)
	var i LogEntry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Description,
		&i.Type,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMinutes,
		&i.ValueRating,
		&i.ImpactLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLogEntry = `-- name: DeleteLogEntry :execrows
DELETE FROM log_entries
WHERE id = $1 AND user_id = $2
`

type DeleteLogEntryParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteLogEntry(ctx context.Context, arg DeleteLogEntryParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteLogEntry, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getDailyProductivityStats = `-- name: GetDailyProductivityStats :many
SELECT
    DATE(start_time) as activity_date,
    COUNT(*) as entry_count,
    SUM(duration_minutes) as total_minutes,
    AVG(duration_minutes) as avg_duration,
    COUNT(CASE WHEN value_rating = 'critical' THEN 1 END) as critical_count,
    COUNT(CASE WHEN value_rating = 'high' THEN 1 END) as high_count
FROM log_entries
WHERE user_id = $1
  AND start_time >= $2
  AND start_time <= $3
GROUP BY DATE(start_time)
ORDER BY activity_date DESC
`

type GetDailyProductivityStatsParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StartTime_2 pgtype.Timestamptz `db:"start_time_2" json:"start_time_2"`
}

type GetDailyProductivityStatsRow struct {
	ActivityDate  pgtype.Date `db:"activity_date" json:"activity_date"`
	EntryCount    int64       `db:"entry_count" json:"entry_count"`
	TotalMinutes  int64       `db:"total_minutes" json:"total_minutes"`
	AvgDuration   float64     `db:"avg_duration" json:"avg_duration"`
	CriticalCount int64       `db:"critical_count" json:"critical_count"`
	HighCount     int64       `db:"high_count" json:"high_count"`
}

func (q *Queries) GetDailyProductivityStats(ctx context.Context, arg GetDailyProductivityStatsParams) ([]GetDailyProductivityStatsRow, error) {
	rows, err := q.db.Query(ctx, getDailyProductivityStats, arg.UserID, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyProductivityStatsRow{}
	for rows.Next() {
		var i GetDailyProductivityStatsRow
		if err := rows.Scan(
			&i.ActivityDate,
			&i.EntryCount,
			&i.TotalMinutes,
			&i.AvgDuration,
			&i.CriticalCount,
			&i.HighCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHighValueEntries = `-- name: GetHighValueEntries :many
SELECT id, user_id, project_id, title, description, type, start_time, end_time, duration_minutes, value_rating, impact_level, created_at, updated_at FROM log_entries
WHERE user_id = $1
  AND value_rating IN ('high', 'critical')
  AND start_time >= $2
ORDER BY start_time DESC
`

type GetHighValueEntriesParams struct {
	UserID    uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime pgtype.Timestamptz `db:"start_time" json:"start_time"`
}

func (q *Queries) GetHighValueEntries(ctx context.Context, arg GetHighValueEntriesParams) ([]LogEntry, error) {
	rows, err := q.db.Query(ctx, getHighValueEntries, arg.UserID, arg.StartTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogEntry{}
	for rows.Next() {
		var i LogEntry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.ValueRating,
			&i.ImpactLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogEntriesByProject = `-- name: GetLogEntriesByProject :many
SELECT id, user_id, project_id, title, description, type, start_time, end_time, duration_minutes, value_rating, impact_level, created_at, updated_at FROM log_entries
WHERE project_id = $1
ORDER BY start_time DESC
`

func (q *Queries) GetLogEntriesByProject(ctx context.Context, projectID pgtype.UUID) ([]LogEntry, error) {
	rows, err := q.db.Query(ctx, getLogEntriesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogEntry{}
	for rows.Next() {
		var i LogEntry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.ValueRating,
			&i.ImpactLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogEntriesByType = `-- name: GetLogEntriesByType :many
SELECT id, user_id, project_id, title, description, type, start_time, end_time, duration_minutes, value_rating, impact_level, created_at, updated_at FROM log_entries
WHERE user_id = $1 AND type = $2
ORDER BY start_time DESC
`

type GetLogEntriesByTypeParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Type   string    `db:"type" json:"type"`
}

func (q *Queries) GetLogEntriesByType(ctx context.Context, arg GetLogEntriesByTypeParams) ([]LogEntry, error) {
	rows, err := q.db.Query(ctx, getLogEntriesByType, arg.UserID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogEntry{}
	for rows.Next() {
		var i LogEntry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.ValueRating,
			&i.ImpactLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogEntriesByUser = `-- name: GetLogEntriesByUser :many
SELECT id, user_id, project_id, title, description, type, start_time, end_time, duration_minutes, value_rating, impact_level, created_at, updated_at FROM log_entries
WHERE user_id = $1
ORDER BY start_time DESC
LIMIT $2 OFFSET $3
`

type GetLogEntriesByUserParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

func (q *Queries) GetLogEntriesByUser(ctx context.Context, arg GetLogEntriesByUserParams) ([]LogEntry, error) {
	rows, err := q.db.Query(ctx, getLogEntriesByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogEntry{}
	for rows.Next() {
		var i LogEntry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.ValueRating,
			&i.ImpactLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogEntriesByUserAndDateRange = `-- name: GetLogEntriesByUserAndDateRange :many
SELECT id, user_id, project_id, title, description, type, start_time, end_time, duration_minutes, value_rating, impact_level, created_at, updated_at FROM log_entries
WHERE user_id = $1
  AND start_time >= $2
  AND end_time <= $3
ORDER BY start_time ASC
`

type GetLogEntriesByUserAndDateRangeParams struct {
	UserID    uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime pgtype.Timestamptz `db:"start_time" json:"start_time"`
	EndTime   pgtype.Timestamptz `db:"end_time" json:"end_time"`
}

func (q *Queries) GetLogEntriesByUserAndDateRange(ctx context.Context, arg GetLogEntriesByUserAndDateRangeParams) ([]LogEntry, error) {
	rows, err := q.db.Query(ctx, getLogEntriesByUserAndDateRange, arg.UserID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogEntry{}
	for rows.Next() {
		var i LogEntry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.ValueRating,
			&i.ImpactLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogEntriesByUserAndProject = `-- name: GetLogEntriesByUserAndProject :many
SELECT id, user_id, project_id, title, description, type, start_time, end_time, duration_minutes, value_rating, impact_level, created_at, updated_at FROM log_entries
WHERE user_id = $1 AND project_id = $2
ORDER BY start_time DESC
`

type GetLogEntriesByUserAndProjectParams struct {
	UserID    uuid.UUID   `db:"user_id" json:"user_id"`
	ProjectID pgtype.UUID `db:"project_id" json:"project_id"`
}

func (q *Queries) GetLogEntriesByUserAndProject(ctx context.Context, arg GetLogEntriesByUserAndProjectParams) ([]LogEntry, error) {
	rows, err := q.db.Query(ctx, getLogEntriesByUserAndProject, arg.UserID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogEntry{}
	for rows.Next() {
		var i LogEntry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.ValueRating,
			&i.ImpactLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogEntriesWithTags = `-- name: GetLogEntriesWithTags :many
SELECT DISTINCT le.id, le.user_id, le.project_id, le.title, le.description, le.type, le.start_time, le.end_time, le.duration_minutes, le.value_rating, le.impact_level, le.created_at, le.updated_at,
       ARRAY_AGG(t.name ORDER BY t.name) as tag_names
FROM log_entries le
LEFT JOIN log_entry_tags let ON le.id = let.log_entry_id
LEFT JOIN tags t ON let.tag_id = t.id
WHERE le.user_id = $1
  AND le.start_time >= $2
  AND le.start_time <= $3
GROUP BY le.id
ORDER BY le.start_time DESC
`

type GetLogEntriesWithTagsParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StartTime_2 pgtype.Timestamptz `db:"start_time_2" json:"start_time_2"`
}

type GetLogEntriesWithTagsRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	UserID          uuid.UUID          `db:"user_id" json:"user_id"`
	ProjectID       pgtype.UUID        `db:"project_id" json:"project_id"`
	Title           string             `db:"title" json:"title"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Type            string             `db:"type" json:"type"`
	StartTime       pgtype.Timestamptz `db:"start_time" json:"start_time"`
	EndTime         pgtype.Timestamptz `db:"end_time" json:"end_time"`
	DurationMinutes pgtype.Int4        `db:"duration_minutes" json:"duration_minutes"`
	ValueRating     string             `db:"value_rating" json:"value_rating"`
	ImpactLevel     string             `db:"impact_level" json:"impact_level"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	TagNames        interface{}        `db:"tag_names" json:"tag_names"`
}

func (q *Queries) GetLogEntriesWithTags(ctx context.Context, arg GetLogEntriesWithTagsParams) ([]GetLogEntriesWithTagsRow, error) {
	rows, err := q.db.Query(ctx, getLogEntriesWithTags, arg.UserID, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLogEntriesWithTagsRow{}
	for rows.Next() {
		var i GetLogEntriesWithTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.ValueRating,
			&i.ImpactLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TagNames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogEntryByID = `-- name: GetLogEntryByID :one
SELECT id, user_id, project_id, title, description, type, start_time, end_time, duration_minutes, value_rating, impact_level, created_at, updated_at FROM log_entries
WHERE id = $1
`

func (q *Queries) GetLogEntryByID(ctx context.Context, id uuid.UUID) (LogEntry, error) {
	row := q.db.QueryRow(ctx, getLogEntryByID, id)
	var i LogEntry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Description,
		&i.Type,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMinutes,
		&i.ValueRating,
		&i.ImpactLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecentLogEntries = `-- name: GetRecentLogEntries :many
SELECT le.id, le.user_id, le.project_id, le.title, le.description, le.type, le.start_time, le.end_time, le.duration_minutes, le.value_rating, le.impact_level, le.created_at, le.updated_at, p.name as project_name, p.color as project_color
FROM log_entries le
LEFT JOIN projects p ON le.project_id = p.id
WHERE le.user_id = $1
ORDER BY le.start_time DESC
LIMIT $2
`

type GetRecentLogEntriesParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Limit  int32     `db:"limit" json:"limit"`
}

type GetRecentLogEntriesRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	UserID          uuid.UUID          `db:"user_id" json:"user_id"`
	ProjectID       pgtype.UUID        `db:"project_id" json:"project_id"`
	Title           string             `db:"title" json:"title"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Type            string             `db:"type" json:"type"`
	StartTime       pgtype.Timestamptz `db:"start_time" json:"start_time"`
	EndTime         pgtype.Timestamptz `db:"end_time" json:"end_time"`
	DurationMinutes pgtype.Int4        `db:"duration_minutes" json:"duration_minutes"`
	ValueRating     string             `db:"value_rating" json:"value_rating"`
	ImpactLevel     string             `db:"impact_level" json:"impact_level"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	ProjectName     pgtype.Text        `db:"project_name" json:"project_name"`
	ProjectColor    pgtype.Text        `db:"project_color" json:"project_color"`
}

func (q *Queries) GetRecentLogEntries(ctx context.Context, arg GetRecentLogEntriesParams) ([]GetRecentLogEntriesRow, error) {
	rows, err := q.db.Query(ctx, getRecentLogEntries, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentLogEntriesRow{}
	for rows.Next() {
		var i GetRecentLogEntriesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.ValueRating,
			&i.ImpactLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectName,
			&i.ProjectColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActivitySummary = `-- name: GetUserActivitySummary :one
SELECT
    COUNT(*) as total_entries,
    SUM(duration_minutes) as total_minutes,
    AVG(duration_minutes) as avg_duration,
    COUNT(DISTINCT project_id) as projects_count,
    COUNT(DISTINCT DATE(start_time)) as active_days
FROM log_entries
WHERE user_id = $1
  AND start_time >= $2
  AND start_time <= $3
`

type GetUserActivitySummaryParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StartTime_2 pgtype.Timestamptz `db:"start_time_2" json:"start_time_2"`
}

type GetUserActivitySummaryRow struct {
	TotalEntries  int64   `db:"total_entries" json:"total_entries"`
	TotalMinutes  int64   `db:"total_minutes" json:"total_minutes"`
	AvgDuration   float64 `db:"avg_duration" json:"avg_duration"`
	ProjectsCount int64   `db:"projects_count" json:"projects_count"`
	ActiveDays    int64   `db:"active_days" json:"active_days"`
}

func (q *Queries) GetUserActivitySummary(ctx context.Context, arg GetUserActivitySummaryParams) (GetUserActivitySummaryRow, error) {
	row := q.db.QueryRow(ctx, getUserActivitySummary, arg.UserID, arg.StartTime, arg.StartTime_2)
	var i GetUserActivitySummaryRow
	err := row.Scan(
		&i.TotalEntries,
		&i.TotalMinutes,
		&i.AvgDuration,
		&i.ProjectsCount,
		&i.ActiveDays,
	)
	return i, err
}

const searchLogEntries = `-- name: SearchLogEntries :many
SELECT id, user_id, project_id, title, description, type, start_time, end_time, duration_minutes, value_rating, impact_level, created_at, updated_at FROM log_entries
WHERE user_id = $1
  AND (
    title ILIKE '%' || $2 || '%' OR
    description ILIKE '%' || $2 || '%'
  )
ORDER BY start_time DESC
LIMIT $3
`

type SearchLogEntriesParams struct {
	UserID  uuid.UUID   `db:"user_id" json:"user_id"`
	Column2 pgtype.Text `db:"column_2" json:"column_2"`
	Limit   int32       `db:"limit" json:"limit"`
}

func (q *Queries) SearchLogEntries(ctx context.Context, arg SearchLogEntriesParams) ([]LogEntry, error) {
	rows, err := q.db.Query(ctx, searchLogEntries, arg.UserID, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogEntry{}
	for rows.Next() {
		var i LogEntry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.Type,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.ValueRating,
			&i.ImpactLevel,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLogEntry = `-- name: UpdateLogEntry :one
UPDATE log_entries
SET title = $2, description = $3, type = $4, project_id = $5,
    start_time = $6, end_time = $7, value_rating = $8,
    impact_level = $9, updated_at = NOW()
WHERE id = $1 AND user_id = $10
RETURNING id, user_id, project_id, title, description, type, start_time, end_time, duration_minutes, value_rating, impact_level, created_at, updated_at
`

type UpdateLogEntryParams struct {
	ID          uuid.UUID          `db:"id" json:"id"`
	Title       string             `db:"title" json:"title"`
	Description pgtype.Text        `db:"description" json:"description"`
	Type        string             `db:"type" json:"type"`
	ProjectID   pgtype.UUID        `db:"project_id" json:"project_id"`
	StartTime   pgtype.Timestamptz `db:"start_time" json:"start_time"`
	EndTime     pgtype.Timestamptz `db:"end_time" json:"end_time"`
	ValueRating string             `db:"value_rating" json:"value_rating"`
	ImpactLevel string             `db:"impact_level" json:"impact_level"`
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateLogEntry(ctx context.Context, arg UpdateLogEntryParams) (LogEntry, error) {
	row := q.db.QueryRow(ctx, updateLogEntry,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Type,
		arg.ProjectID,
		arg.StartTime,
		arg.EndTime,
		arg.ValueRating,
		arg.ImpactLevel,
		arg.UserID,
	)
	var i LogEntry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.Description,
		&i.Type,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMinutes,
		&i.ValueRating,
		&i.ImpactLevel,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
