// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tasks.sql

package store

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelTask = `-- name: CancelTask :exec
UPDATE tasks
SET status = 'cancelled', updated_at = NOW()
WHERE id = $1 AND status IN ('pending', 'retrying')
`

func (q *Queries) CancelTask(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, cancelTask, id)
	return err
}

const cleanupOldTasks = `-- name: CleanupOldTasks :exec
DELETE FROM tasks
WHERE status IN ('completed', 'failed', 'cancelled')
  AND completed_at < $1
`

func (q *Queries) CleanupOldTasks(ctx context.Context, completedAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, cleanupOldTasks, completedAt)
	return err
}

const completeTask = `-- name: CompleteTask :one
UPDATE tasks
SET status = 'completed', result = $2, completed_at = NOW(),
    processing_duration_ms = EXTRACT(EPOCH FROM (NOW() - started_at)) * 1000,
    updated_at = NOW()
WHERE id = $1
RETURNING id, task_type, user_id, payload, status, priority, max_retries, retry_count, scheduled_at, started_at, completed_at, result, error_message, processing_duration_ms, created_at, updated_at
`

type CompleteTaskParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	Result []byte    `db:"result" json:"result"`
}

func (q *Queries) CompleteTask(ctx context.Context, arg CompleteTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, completeTask, arg.ID, arg.Result)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.TaskType,
		&i.UserID,
		&i.Payload,
		&i.Status,
		&i.Priority,
		&i.MaxRetries,
		&i.RetryCount,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Result,
		&i.ErrorMessage,
		&i.ProcessingDurationMs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one

INSERT INTO tasks (
    task_type, user_id, payload, priority, max_retries, scheduled_at
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, task_type, user_id, payload, status, priority, max_retries, retry_count, scheduled_at, started_at, completed_at, result, error_message, processing_duration_ms, created_at, updated_at
`

type CreateTaskParams struct {
	TaskType    string             `db:"task_type" json:"task_type"`
	UserID      pgtype.UUID        `db:"user_id" json:"user_id"`
	Payload     []byte             `db:"payload" json:"payload"`
	Priority    pgtype.Int4        `db:"priority" json:"priority"`
	MaxRetries  pgtype.Int4        `db:"max_retries" json:"max_retries"`
	ScheduledAt pgtype.Timestamptz `db:"scheduled_at" json:"scheduled_at"`
}

// EngLog Task Management Queries
// Background task processing and job queue
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.TaskType,
		arg.UserID,
		arg.Payload,
		arg.Priority,
		arg.MaxRetries,
		arg.ScheduledAt,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.TaskType,
		&i.UserID,
		&i.Payload,
		&i.Status,
		&i.Priority,
		&i.MaxRetries,
		&i.RetryCount,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Result,
		&i.ErrorMessage,
		&i.ProcessingDurationMs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const failTask = `-- name: FailTask :one
UPDATE tasks
SET status = CASE
    WHEN retry_count < max_retries THEN 'retrying'
    ELSE 'failed'
    END,
    retry_count = retry_count + 1,
    error_message = $2,
    scheduled_at = CASE
        WHEN retry_count < max_retries THEN NOW() + INTERVAL '5 minutes' * (retry_count + 1)
        ELSE scheduled_at
    END,
    updated_at = NOW()
WHERE id = $1
RETURNING id, task_type, user_id, payload, status, priority, max_retries, retry_count, scheduled_at, started_at, completed_at, result, error_message, processing_duration_ms, created_at, updated_at
`

type FailTaskParams struct {
	ID           uuid.UUID   `db:"id" json:"id"`
	ErrorMessage pgtype.Text `db:"error_message" json:"error_message"`
}

func (q *Queries) FailTask(ctx context.Context, arg FailTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, failTask, arg.ID, arg.ErrorMessage)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.TaskType,
		&i.UserID,
		&i.Payload,
		&i.Status,
		&i.Priority,
		&i.MaxRetries,
		&i.RetryCount,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Result,
		&i.ErrorMessage,
		&i.ProcessingDurationMs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingTasks = `-- name: GetPendingTasks :many
SELECT id, task_type, user_id, payload, status, priority, max_retries, retry_count, scheduled_at, started_at, completed_at, result, error_message, processing_duration_ms, created_at, updated_at FROM tasks
WHERE status IN ('pending', 'retrying')
  AND scheduled_at <= NOW()
ORDER BY priority ASC, scheduled_at ASC
LIMIT $1
`

func (q *Queries) GetPendingTasks(ctx context.Context, limit int32) ([]Task, error) {
	rows, err := q.db.Query(ctx, getPendingTasks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.TaskType,
			&i.UserID,
			&i.Payload,
			&i.Status,
			&i.Priority,
			&i.MaxRetries,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Result,
			&i.ErrorMessage,
			&i.ProcessingDurationMs,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStuckTasks = `-- name: GetStuckTasks :many
SELECT id, task_type, user_id, payload, status, priority, max_retries, retry_count, scheduled_at, started_at, completed_at, result, error_message, processing_duration_ms, created_at, updated_at FROM tasks
WHERE status = 'processing'
  AND started_at < NOW() - INTERVAL '1 hour'
ORDER BY started_at ASC
`

func (q *Queries) GetStuckTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.Query(ctx, getStuckTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.TaskType,
			&i.UserID,
			&i.Payload,
			&i.Status,
			&i.Priority,
			&i.MaxRetries,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Result,
			&i.ErrorMessage,
			&i.ProcessingDurationMs,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT id, task_type, user_id, payload, status, priority, max_retries, retry_count, scheduled_at, started_at, completed_at, result, error_message, processing_duration_ms, created_at, updated_at FROM tasks
WHERE id = $1
`

func (q *Queries) GetTaskByID(ctx context.Context, id uuid.UUID) (Task, error) {
	row := q.db.QueryRow(ctx, getTaskByID, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.TaskType,
		&i.UserID,
		&i.Payload,
		&i.Status,
		&i.Priority,
		&i.MaxRetries,
		&i.RetryCount,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Result,
		&i.ErrorMessage,
		&i.ProcessingDurationMs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTaskPerformanceMetrics = `-- name: GetTaskPerformanceMetrics :many
SELECT
    task_type,
    COUNT(*) as total_executed,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as successful,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed,
    AVG(processing_duration_ms) as avg_duration,
    AVG(retry_count) as avg_retries
FROM tasks
WHERE completed_at >= $1
GROUP BY task_type
ORDER BY total_executed DESC
`

type GetTaskPerformanceMetricsRow struct {
	TaskType      string  `db:"task_type" json:"task_type"`
	TotalExecuted int64   `db:"total_executed" json:"total_executed"`
	Successful    int64   `db:"successful" json:"successful"`
	Failed        int64   `db:"failed" json:"failed"`
	AvgDuration   float64 `db:"avg_duration" json:"avg_duration"`
	AvgRetries    float64 `db:"avg_retries" json:"avg_retries"`
}

func (q *Queries) GetTaskPerformanceMetrics(ctx context.Context, completedAt pgtype.Timestamptz) ([]GetTaskPerformanceMetricsRow, error) {
	rows, err := q.db.Query(ctx, getTaskPerformanceMetrics, completedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTaskPerformanceMetricsRow{}
	for rows.Next() {
		var i GetTaskPerformanceMetricsRow
		if err := rows.Scan(
			&i.TaskType,
			&i.TotalExecuted,
			&i.Successful,
			&i.Failed,
			&i.AvgDuration,
			&i.AvgRetries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskQueue = `-- name: GetTaskQueue :many
SELECT
    task_type,
    status,
    COUNT(*) as task_count,
    AVG(EXTRACT(EPOCH FROM (NOW() - scheduled_at))) as avg_wait_time_seconds
FROM tasks
WHERE created_at >= NOW() - INTERVAL '24 hours'
GROUP BY task_type, status
ORDER BY task_type, status
`

type GetTaskQueueRow struct {
	TaskType           string      `db:"task_type" json:"task_type"`
	Status             pgtype.Text `db:"status" json:"status"`
	TaskCount          int64       `db:"task_count" json:"task_count"`
	AvgWaitTimeSeconds float64     `db:"avg_wait_time_seconds" json:"avg_wait_time_seconds"`
}

func (q *Queries) GetTaskQueue(ctx context.Context) ([]GetTaskQueueRow, error) {
	rows, err := q.db.Query(ctx, getTaskQueue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTaskQueueRow{}
	for rows.Next() {
		var i GetTaskQueueRow
		if err := rows.Scan(
			&i.TaskType,
			&i.Status,
			&i.TaskCount,
			&i.AvgWaitTimeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskStats = `-- name: GetTaskStats :one
SELECT
    COUNT(*) as total_tasks,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_tasks,
    COUNT(CASE WHEN status = 'processing' THEN 1 END) as processing_tasks,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_tasks,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_tasks,
    AVG(processing_duration_ms) as avg_processing_time
FROM tasks
WHERE created_at >= $1
`

type GetTaskStatsRow struct {
	TotalTasks        int64   `db:"total_tasks" json:"total_tasks"`
	PendingTasks      int64   `db:"pending_tasks" json:"pending_tasks"`
	ProcessingTasks   int64   `db:"processing_tasks" json:"processing_tasks"`
	CompletedTasks    int64   `db:"completed_tasks" json:"completed_tasks"`
	FailedTasks       int64   `db:"failed_tasks" json:"failed_tasks"`
	AvgProcessingTime float64 `db:"avg_processing_time" json:"avg_processing_time"`
}

func (q *Queries) GetTaskStats(ctx context.Context, createdAt pgtype.Timestamptz) (GetTaskStatsRow, error) {
	row := q.db.QueryRow(ctx, getTaskStats, createdAt)
	var i GetTaskStatsRow
	err := row.Scan(
		&i.TotalTasks,
		&i.PendingTasks,
		&i.ProcessingTasks,
		&i.CompletedTasks,
		&i.FailedTasks,
		&i.AvgProcessingTime,
	)
	return i, err
}

const getTasksByType = `-- name: GetTasksByType :many
SELECT id, task_type, user_id, payload, status, priority, max_retries, retry_count, scheduled_at, started_at, completed_at, result, error_message, processing_duration_ms, created_at, updated_at FROM tasks
WHERE task_type = $1
ORDER BY created_at DESC
`

func (q *Queries) GetTasksByType(ctx context.Context, taskType string) ([]Task, error) {
	rows, err := q.db.Query(ctx, getTasksByType, taskType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.TaskType,
			&i.UserID,
			&i.Payload,
			&i.Status,
			&i.Priority,
			&i.MaxRetries,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Result,
			&i.ErrorMessage,
			&i.ProcessingDurationMs,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksByUser = `-- name: GetTasksByUser :many
SELECT id, task_type, user_id, payload, status, priority, max_retries, retry_count, scheduled_at, started_at, completed_at, result, error_message, processing_duration_ms, created_at, updated_at FROM tasks
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetTasksByUserParams struct {
	UserID pgtype.UUID `db:"user_id" json:"user_id"`
	Limit  int32       `db:"limit" json:"limit"`
	Offset int32       `db:"offset" json:"offset"`
}

func (q *Queries) GetTasksByUser(ctx context.Context, arg GetTasksByUserParams) ([]Task, error) {
	rows, err := q.db.Query(ctx, getTasksByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.TaskType,
			&i.UserID,
			&i.Payload,
			&i.Status,
			&i.Priority,
			&i.MaxRetries,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Result,
			&i.ErrorMessage,
			&i.ProcessingDurationMs,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTaskHistory = `-- name: GetUserTaskHistory :many
SELECT id, task_type, user_id, payload, status, priority, max_retries, retry_count, scheduled_at, started_at, completed_at, result, error_message, processing_duration_ms, created_at, updated_at FROM tasks
WHERE user_id = $1
  AND created_at >= $2
ORDER BY created_at DESC
`

type GetUserTaskHistoryParams struct {
	UserID    pgtype.UUID        `db:"user_id" json:"user_id"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) GetUserTaskHistory(ctx context.Context, arg GetUserTaskHistoryParams) ([]Task, error) {
	rows, err := q.db.Query(ctx, getUserTaskHistory, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.TaskType,
			&i.UserID,
			&i.Payload,
			&i.Status,
			&i.Priority,
			&i.MaxRetries,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Result,
			&i.ErrorMessage,
			&i.ProcessingDurationMs,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetStuckTasks = `-- name: ResetStuckTasks :exec
UPDATE tasks
SET status = 'pending', started_at = NULL, updated_at = NOW()
WHERE status = 'processing'
  AND started_at < NOW() - INTERVAL '1 hour'
`

func (q *Queries) ResetStuckTasks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetStuckTasks)
	return err
}

const startTaskProcessing = `-- name: StartTaskProcessing :one
UPDATE tasks
SET status = 'processing', started_at = NOW(), updated_at = NOW()
WHERE id = $1 AND status IN ('pending', 'retrying')
RETURNING id, task_type, user_id, payload, status, priority, max_retries, retry_count, scheduled_at, started_at, completed_at, result, error_message, processing_duration_ms, created_at, updated_at
`

func (q *Queries) StartTaskProcessing(ctx context.Context, id uuid.UUID) (Task, error) {
	row := q.db.QueryRow(ctx, startTaskProcessing, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.TaskType,
		&i.UserID,
		&i.Payload,
		&i.Status,
		&i.Priority,
		&i.MaxRetries,
		&i.RetryCount,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Result,
		&i.ErrorMessage,
		&i.ProcessingDurationMs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :one
UPDATE tasks
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, task_type, user_id, payload, status, priority, max_retries, retry_count, scheduled_at, started_at, completed_at, result, error_message, processing_duration_ms, created_at, updated_at
`

type UpdateTaskStatusParams struct {
	ID     uuid.UUID   `db:"id" json:"id"`
	Status pgtype.Text `db:"status" json:"status"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) (Task, error) {
	row := q.db.QueryRow(ctx, updateTaskStatus, arg.ID, arg.Status)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.TaskType,
		&i.UserID,
		&i.Payload,
		&i.Status,
		&i.Priority,
		&i.MaxRetries,
		&i.RetryCount,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Result,
		&i.ErrorMessage,
		&i.ProcessingDurationMs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
